'''
wx.lib.plot.plotcanvas has a bug in plotcanvas.SaveFile() method, which
should be fixed for running in Python 3.

    ftype = _string.lower(fileName[-3:]) -> ftype = fileName[-3:].lower()

'''

import numpy as np
import queue
import sounddevice as sd
import soundfile as sf
import sys
import threading
import wx

from waveform import *
from wx.lib import plot as wxplot
from wx.lib.embeddedimage import PyEmbeddedImage


# following embedded images are generated by img2py()
peiPlay = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAABGdBTUEAALGPC/xhBQAAACBj'
    b'SFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAKqNIzIA'
    b'AAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfhCRMODRWMnU8rAAABHklEQVQ4y53UvUoD'
    b'QRQF4M/VV1AhRSBlOmE3rXYi5BEEbX0HTeeL+AKpxUKw1Q3YWaayiELawIJci43JblyRzZlm'
    b'5t75OefOmdlRx4GBTCpDbiL34sMf2DNSiI1WGNlbT9pZ9fruDMDMRI5M6hC8uPRW3/3CQghj'
    b'vVq8ZyyEhYtquG8hzJ03Uj03Fxb6a+7Pwlz3L3G65sLzj5aREJXdOxVl61NCGJWFLIRxJXnl'
    b'3v6vJWOhcMBQiJrUK+Hd8caCnhCGiQwz0410x6PrGrWpGbJEikmD0F23G9QmSJOlCZpx6tXJ'
    b'apSXJ7REsjRBMx4ceVqNMuRJyaxh8pcbZz4rkaXalmXd4uJaW2ML87W2Ny0e0NZPtNTS6hMo'
    b'8e838w3+P5FtfWr/GgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNy0wOS0xOVQxNDoxMzoyMSsw'
    b'MjowMKJqEq4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTctMDktMTlUMTQ6MTM6MjErMDI6MDDT'
    b'N6oSAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==')

peiSave = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlw'
    b'SFlzAAADsAAAA7ABJ8QPrQAAAWxJREFUSInVlr1KA0EUhb8bgrERBMEylRbRBwgWggbtbMRC'
    b'UKt0qVJYamvjO9jZCIKK4gvYCVZBtA1apBIUlYA/xyKzuK6z2WRxAx4Y5nL3zjlz7/ytSSJL'
    b'5DJlB/KBYWY5oAwM9TG+DVxJeo+NkIQr0w6gFO0OmAt4oi1comngBagCB565HLpvVWDf+fZc'
    b'xudmVknK4Bh4cPamZ6a1UOy68y0AJaAFvAKVbhmkgqQbYB54As6imfzJLvKITKURsBg7LLII'
    b'FIB64M9HAx0+PL4tM1tzdtEXJ6lhZvfARJLAEbAKjEX8465vA6fApWesCGXoFZDUBGZixPtC'
    b'5lfF4O6iMMxsEjjh9xrE4RFYkdToSQBYonNCL4DnBPJhOmdgGehZIChdTdJ1N3YzKwJNYsr9'
    b'/xd5oLtIQMHM6sCs822YWSuBY9T1ZTd2xHE51u87fpt0L5qv7Qa8Fv6rMLMS/b3JPrwBt5I+'
    b'gZ8CWeALA9y6UzVKmtYAAAAASUVORK5CYII=')

peiStop = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAABGdBTUEAALGPC/xhBQAAACBj'
    b'SFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAKqNIzIA'
    b'AAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfhCRMODAzx7daqAAABC0lEQVQ4y53UOXLC'
    b'QBAF0IfKEHAAIt8BKKScnEs45gpUGeGT+CjkEovv4Mg5DoZgHIh9KZD/JFM9v9fp7oZzdGRS'
    b'AylKC6XCjztoygXx4gRTzSOpcbj1fOri10qhQCbT18aXN+tz62NBFMy0zuQts93L+FTcE0RL'
    b'3Zuhdi1FQe8Y+1q0PI30KrulaL1n5KJwx/rRSxBNaej41vRhCoaGF9S5OZh5t/XKSLQ5pJpf'
    b'lTU/pL8RjRIpVoJHCFZIEwMUD+l2rEHl4XmFNHmKeoJEiewpboYysailsKg89C866BZa+ihf'
    b'FLbaJruPm18R95KJtm1VnlqtwT+ar3Z7U2OA/j2iVaS1lkCFh2vmD02ah5GJdl4nAAAAJXRF'
    b'WHRkYXRlOmNyZWF0ZQAyMDE3LTA5LTE5VDE0OjEyOjEyKzAyOjAw8s9k7gAAACV0RVh0ZGF0'
    b'ZTptb2RpZnkAMjAxNy0wOS0xOVQxNDoxMjoxMiswMjowMIOS3FIAAAAZdEVYdFNvZnR3YXJl'
    b'AHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC')

SamplingFreq = 48000
PaneMinWidth = 10

Waveforms = [
        SineWave(), 
        SquareWave(),
        SawtoothWave(),
        TriangleWave(),
        Chirp('Linear Chirp'),
        Chirp('Exponential Chirp'),
        PseudoNoise() ]
Frequencies = [100,200,500,1000,2000,4800,5000,10000,15000]
Durations = [1, 5, 10, 30, 60]

WaveList = [x.GetName() for x in Waveforms]
FreqList = [str(x) for x in Frequencies]
DursList = [str(x) for x in Durations]
DursList.append('Continuous')

q = queue.Queue()
evt = threading.Event()

def callback(outdata, frames, time, status):
    if status.output_underflow:
        print('output underflow', file=sys.stderr)
        raise sd.CallbackAbort

    try:
        data = q.get()
    except:
        print('queue is empty', file=sys.stderr)
        raise sd.CallbackAbort

    if len(data) < len(outdata):
        outdata[:len(data)] = data
        outdata[len(data):] = b'\x00' * (len(outdata) - len(data))
        raise sd.CallbackStop
    else:
        outdata[:] = data


class InnoPlotCanvas(wx.lib.plot.PlotCanvas):
    '''
    Duplication of wx.lib.plot.PlotCanvas. The reference windows size is
    changed from self.canvas to self.parent so that when embedded in a 
    splitter window the graph size remains the same during the sash motion.
    '''

    def __init__(self, *args, **kwgs):
        wx.lib.plot.PlotCanvas.__init__(self, *args, **kwgs)

    def OnSize(self, event):
        # change the reference size from self.canvas to self.parent
        # Size = self.canvas.GetClientSize()
        Size = self.GetParent().GetClientSize()
        Size.width = max(1, Size.width - PaneMinWidth)
        Size.height = max(1, Size.height)

        # Make new offscreen bitmap: this bitmap will always have the
        # current drawing in it, so it can be used to save the image to
        # a file, or whatever.
        self._Buffer = wx.Bitmap(Size.width, Size.height)
        self._setSize()

        self.last_PointLabel = None  # reset pointLabel

        if self.last_draw is None:
            self.Clear()
        else:
            graphics, xSpec, ySpec = self.last_draw
            self._Draw(graphics, xSpec, ySpec)

    def _setSize(self, width=None, height=None):
        """DC width and height."""
        if width is None:
            # change the reference size from canvas to parent
            #(self.width, self.height) = self.canvas.GetClientSize()
            Size = self.GetParent().GetClientSize()
            (self.width, self.height) = (Size.width - PaneMinWidth, Size.height)
        else:
            self.width, self.height = width, height
        self.width *= self._pointSize[0]  # high precision
        self.height *= self._pointSize[1]  # high precision
        self.plotbox_size = 0.97 * np.array([self.width, self.height])
        xo = 0.5 * (self.width - self.plotbox_size[0])
        yo = self.height - 0.5 * (self.height - self.plotbox_size[1])
        self.plotbox_origin = np.array([xo, yo])


class InnoDualPlot(wx.SplitterWindow):
    '''
    Dual PlotCanvas in a splitter window
    '''

    def __init__(self, *args, **kwgs):
        wx.SplitterWindow.__init__(self, *args, **kwgs)

        # left plot
        self.cnv1 = InnoPlotCanvas(self)
        self.cnv1.enableAntiAliasing = True
        self.cnv1.ySpec = (-1,1)

        # right plot with log-log scale
        self.cnv2 = InnoPlotCanvas(self)
        self.cnv2.enableAntiAliasing = True
        self.cnv2.logScale = (True,True)

        self.SetMinimumPaneSize(PaneMinWidth)
        self.SplitVertically(self.cnv1, self.cnv2, -1 - PaneMinWidth)


    def DrawGraphics(self, grp1=None, grp2=None):
        if grp1 is not None:
            self.cnv1.Draw(grp1)
        if grp2 is not None:
            self.cnv2.Draw(grp2)

    def GetCanvases(self):
        return (self.cnv1, self.cnv2)


class InnoWav(wx.Panel):

    def __init__(self, *args, **kwgs):

        wx.Panel.__init__(self, *args, **kwgs)

        # dualpane plot window
        self.spw = InnoDualPlot(self)

        # waveform
        self.sttWave = wx.StaticText(self, -1, 'Waveform')
        self.choWave = wx.Choice(self, -1, choices=WaveList)
        # frequency
        self.sttFreq = wx.StaticText(self, -1, 'Frequency(Hz)')
        self.choFreq = wx.Choice(self, -1, choices=FreqList)
        # duration
        self.sttTime = wx.StaticText(self, -1, 'Duration(sec)')
        self.choDurs = wx.Choice(self, -1, choices=DursList)
        # amplitude
        self.sttAmpl = wx.StaticText(self, -1, 'Amplitude')
        self.spnAmpl = wx.SpinCtrlDouble(self, -1, value='0.5',
                min = 0.1, max = 1.0, inc = 0.1)
        # offset
        self.sttOffs = wx.StaticText(self, -1, 'Offset')
        self.spnOffs = wx.SpinCtrlDouble(self, -1, value = '0.0',
                min = -1.0, max = 1.0, inc = 0.1)

        # toolbar id
        self.tidPlay = wx.NewId()
        self.tidStop = wx.NewId()
        self.tidSave = wx.NewId()
        # toolbar
        self.toolbar = wx.ToolBar(self)
        # bitmap size
        self.toolbar.SetToolBitmapSize((24,24))
        # toolbar buttons
        self.toolbar.AddTool(self.tidPlay, '', peiPlay.GetBitmap(),
                shortHelp = 'Play')
        self.toolbar.AddTool(self.tidStop, '', peiStop.GetBitmap(),
                shortHelp = 'Stop')
        self.toolbar.AddTool(self.tidSave, '', peiSave.GetBitmap(),
                shortHelp = 'Save')
        self.toolbar.Realize()

        # initial values
        self.choFreq.SetStringSelection('1000')
        self.choDurs.SetStringSelection('1')
        self.spnAmpl.SetValue(0.5)
        self.spnOffs.SetValue(0)

        # message binding
        self.Bind(wx.EVT_TOOL, self.OnToolClick, id=self.tidPlay)
        self.Bind(wx.EVT_TOOL, self.OnToolClick, id=self.tidStop)
        self.Bind(wx.EVT_TOOL, self.OnToolClick, id=self.tidSave)

        self.Bind(wx.EVT_CHOICE, self.OnWaveform, self.choWave)
        self.Bind(wx.EVT_CHOICE, self.OnWaveform, self.choFreq)
        self.Bind(wx.EVT_CHOICE, self.OnWaveform, self.choDurs)

        self.Bind(wx.EVT_SPINCTRLDOUBLE, self.OnWaveform, self.spnAmpl)
        self.Bind(wx.EVT_SPINCTRLDOUBLE, self.OnWaveform, self.spnOffs)


        # arrangement
        sizer_g = wx.GridSizer(5,2,4,4)
        sizer_g.Add(self.sttWave, 1, wx.RIGHT | wx.ALIGN_CENTRE_VERTICAL)
        sizer_g.Add(self.choWave, 1, wx.EXPAND)
        sizer_g.Add(self.sttFreq, 1, wx.RIGHT | wx.ALIGN_CENTRE_VERTICAL)
        sizer_g.Add(self.choFreq, 1, wx.EXPAND)
        sizer_g.Add(self.sttTime, 1, wx.RIGHT | wx.ALIGN_CENTRE_VERTICAL)
        sizer_g.Add(self.choDurs, 1, wx.EXPAND)
        sizer_g.Add(self.sttAmpl, 1, wx.RIGHT | wx.ALIGN_CENTRE_VERTICAL)
        sizer_g.Add(self.spnAmpl, 1, wx.EXPAND)
        sizer_g.Add(self.sttOffs, 1, wx.RIGHT | wx.ALIGN_CENTRE_VERTICAL)
        sizer_g.Add(self.spnOffs, 1, wx.EXPAND)

        sizer_v = wx.BoxSizer(wx.VERTICAL)
        sizer_v.Add(sizer_g, 0, wx.EXPAND|wx.ALL, 4)
        sizer_v.Add((20,20), 1, wx.EXPAND)
        sizer_v.Add(self.toolbar, 0, wx.EXPAND|wx.ALL, 4)

        self.sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer.Add(self.spw, 1, wx.LEFT|wx.TOP|wx.EXPAND)
        self.sizer.Add(sizer_v, 0, wx.LEFT|wx.EXPAND)
        self.SetSizer(self.sizer)
        self.Fit()


    def OnToolClick(self, evt):
        tid = evt.GetId()

        if tid == self.tidPlay: 
            sd.play(self.data, SamplingFreq)

        elif tid == self.tidStop:
            sd.stop()

        if tid == self.tidSave: 
            pass


    def OnWaveform(self, evt):

        wfm = self.choWave.GetStringSelection()
        frq = float(self.choFreq.GetStringSelection())
        amp = self.spnAmpl.GetValue()
        off = self.spnOffs.GetValue()
        '''
        try:
            dur = float(self.choDurs.GetStringSelection())
        except:
            # x in one period
            dur = 1/frq
        '''

        self.GenerateWaveform(wfm, frq, amp, off)

        self.UpdateGraph()


    def GenerateWaveform(self, wfm, frq, amp, off):

        self.data = None

        for w in Waveforms:
            if w.GetName() == wfm:
                w.SetFrequency(frq)
                w.SetAmplitude(amp)
                w.SetOffset(off)
                #(self.x, self.data) = w.GetData(max(100/frq, 0.1))
                (self.x, self.data) = w.GetData(1)
                break


    def UpdateGraph(self):

        if self.data is None:
            return

        wfm = self.choWave.GetStringSelection()
        frq = float(self.choFreq.GetStringSelection())

        # time domain plot
        if 'Chirp' in wfm:
            # display first 500msec only
            dlen = int(SamplingFreq / 2)
        else:
            # display first 20 cycles only
            dlen = int(15*SamplingFreq/frq)

        line1 = wxplot.PolyLine(list(zip(self.x[:dlen],
                self.data[:dlen])), colour='red')
        graph1 = wxplot.PlotGraphics([line1])

        # frequency domain plot
        N = self.data.size
        Y = np.fft.rfft(self.data)/N
        F = np.fft.rfftfreq(N, 1/SamplingFreq)
        line2 = wxplot.PolyLine(list(zip(F, np.abs(Y))))
        graph2 = wxplot.PlotGraphics([line2])

        self.spw.DrawGraphics(graph1, graph2)


if __name__ == "__main__":


    class MyFrame(wx.Frame):

        def __init__(self, parent, title):
            wx.Frame.__init__(self, parent, title=title)

            # panel
            self.pnlPlot = InnoWav(self, size=(640,240))

            # event binding
            self.Bind(wx.EVT_CLOSE, self.OnClose)

            # sizer
            self.sizer = wx.BoxSizer(wx.VERTICAL)
            self.sizer.Add(self.pnlPlot,1, wx.EXPAND)

            self.SetSizer(self.sizer)
            #self.SetAutoLayout(1)
            self.sizer.Fit(self)
            self.Show()



        def OnClose(self, evt):
            # explicitly destroy the panel
            #self.pnlPlot.Close()
            # destroy self
            self.Destroy()


    app = wx.App()
    frame = MyFrame(None, "InnoWav demo")

    app.MainLoop()
